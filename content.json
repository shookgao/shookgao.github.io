{"meta":{"title":"SGBlog","subtitle":"比昨天的自己更好一点儿...","description":null,"author":"Shook Gao","url":"https://shookgao.github.io"},"pages":[{"title":"About SGBlog","date":"2018-06-07T03:44:13.000Z","updated":"2018-06-07T03:47:36.366Z","comments":true,"path":"about/index.html","permalink":"https://shookgao.github.io/about/index.html","excerpt":"","text":"这是一个博客这是我学习记录的地方这是我发布自己程序的地方"}],"posts":[{"title":"Hexo 主题 Hueman 学习笔记","slug":"hexo-theme-hueman","date":"2018-06-04T16:00:00.000Z","updated":"2018-06-05T16:00:00.000Z","comments":true,"path":"2018/06/05/hexo-theme-hueman/","link":"","permalink":"https://shookgao.github.io/2018/06/05/hexo-theme-hueman/","excerpt":"","text":"这个主题是从 WordPress 主题 Hueman 移植过来的，WordPress 版的作者是 AlxMedia，Hexo 版的作者是 ppoffice。特性：响应式布局、主菜单显示分类、自托管网站搜索引擎、自定义评论服务、缩略图、代码高亮、图片廊、自定义侧边栏。我个人挺喜欢这种风格，而且插件什么的也很齐全，所以选择了这款插件做为我自己博客的主题。 目录 安装 配置 插件 安装 在 Hexo 网站根目录执行下面的命令： 1git clone https://github.com/ppoffice/hexo-theme-hueman.git themes/hueman 编辑网站的配置文件 _config.yml,修改 theme 字段的值为 hueman 启用主题： 1theme: hueman 复制主题目录中的 _config.yml.example 为 _config.yml。 安装本地搜索插件： 1npm install -S hexo-generator-json-content 更新主题：在主题目录中执行命令： 1git pull 配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# Menusmenu: # 菜单 Home: / # 首页路径 Categories: # 是否在菜单中使用分类，不使用则删掉此行 About: /about/index.html # 关于页面路径# Customizecustomize: # 定制内容 logo: # logo width: 165 # 宽 height: 60 # 高 url: images/logo.png # logo路径，根目录是./source/css/ theme_color: '#006bde' # 主题颜色 highlight: androidstudio # 高亮主题 sidebar: left # 侧边栏位置，可选 left、right thumbnail: true # 允许文章缩略图 favicon: css/images/favicon.ico # 网站图标路径, 根目录是./source social_links: # 关注，更多图标请查看 http://fontawesome.io/icons/#brand twitter: / # facebook: / google-plus: / github: https://github.com/shookgao weibo: / rss: /# Widgetswidgets: # 侧边栏部件，不需要就删除掉 - catalog - recent_posts - category - archive - tag - tagcloud - links# Searchsearch: # 搜索部件 insight: true # 使用 Insight，需要先安装 `hexo-generator-json-content` swiftype: # 使用 Swiftype，这儿填入Swiftype的安装密钥 baidu: false # 使用百度搜索# Commentcomment: # 评论部件 disqus: hexo-theme-hueman # enter disqus shortname here duoshuo: # enter duoshuo shortname here youyan: # enter youyan uid here facebook: # enter true to enable isso: # enter the domain name of your own comment isso server eg. comments.example.com changyan: appId: # enter the changyan appId here appKey: # enter the changyan appKey here on: # enter true to enable valine: # Valine Comment System https://github.com/xCss/Valine on: # enter true to enable valine appId: # enter the leancloud application appId here appKey: # enter the leancloud application appKey here notify: # enter true to enable &lt;Mail notifier&gt; verify: # enter true to enable &lt;Validation code&gt; placeholder: Just Do It # enter the comment box placeholder avatar: identicon # (''/mm/identicon/monsterid/wavatar/retro/hide), more to see https://valine.js.org/avatar/ avatar_cdn: https://gravatar.loli.net/avatar/ # avatar CDN address, default gravatar.loli.net pageSize: 10 # comments of one page# Share # 分享部件share: default # 选项: jiathis, bdshare, addtoany, default# Pluginsplugins: # 插件 lightgallery: true # 使用相册插件, 选项: true, false justifiedgallery: true # 使用相册插件, 选项: true, false google_analytics: # 使用谷歌分析, 填入你谷歌分析的跟踪 ID baidu_analytics: # 使用百度分析, 填入你百度的哈希密钥 bing_site_verification: # 不太清楚干嘛的, 填入 Bing 的验证密钥 mathjax: false # 使用数学表达式插件, 选项: true, false# Miscellaneousmiscellaneous: # 杂项 open_graph: # see http://ogp.me fb_app_id: fb_admins: twitter_id: google_plus: links: Hexo: http://hexo.io 插件","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://shookgao.github.io/categories/学习笔记/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://shookgao.github.io/tags/学习笔记/"},{"name":"Hexo","slug":"Hexo","permalink":"https://shookgao.github.io/tags/Hexo/"},{"name":"Hueman","slug":"Hueman","permalink":"https://shookgao.github.io/tags/Hueman/"}]},{"title":"Hexo 学习笔记","slug":"hexo","date":"2018-05-29T16:00:00.000Z","updated":"2018-06-06T16:00:00.000Z","comments":true,"path":"2018/05/30/hexo/","link":"","permalink":"https://shookgao.github.io/2018/05/30/hexo/","excerpt":"","text":"官方简介：Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。个人理解：Hexo 是一个可以直接使用的博客服务器端，也是一个静态网站的生成器！它的主要作用是后者，前者通常用来进行本地预览；网上免费的动态空间很少，但是免费的静态空间很多，例如大牌的 Github，我想 Hexo 的主要目标人群应该是那些想利用免费静态空间来建立漂亮博客的人。 目录 环境 安装 配置 使用 插件 其他 环境依赖软件有两个，一个是 NodeJS，因为 Hexo 是它编写的，必须有它才能运行，另一个是 Git，拿来下载一些漂亮的主题；官方有详细的安装教程，我就不赘述了，直接附官方教程。官方教程地址： NodeJS 安装方法：https://nodejs.org/en/download/package-manager/ NodeJS 改国内源：npm install -g cnpm --registry=https://registry.npm.taobao.org，安装以后就可以用 cnpm 命令替代 npm Git 安装方法：https://git-scm.com/book/en/v2/Getting-Started-Installing-Git 安装 安装脚手架： 1npm install -g hexo-cli 使用脚手架创建一个博客： 123hexo init blog_namecd blog_namenpm install 创建完成的目录如下： 1234567├── _config.yml # 主配置文件├── package.json # NodeJS 包文件├── scaffolds # 当您新建文章时，Hexo 会根据 scaffold 来建立文件。对应命令：hexo new├── source # 资源文件夹，也就是你写的.md文章| ├── _drafts # 草稿| └── _posts # 文章└── themes # 主题目录 配置 修改配置文件 _config.yml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: # 网站标题subtitle: # 网站子标题description: # 网站描述，SEO相关keywords: # 关键字，SEO相关author: # 网站作者language: zh-CN # 网站语言，对应多语言文件名timezone: # 时区，默认为本机时区# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: # 网站地址root: / # 网站根目录permalink: :year/:month/:day/:title/ # 文章的链接格式permalink_defaults: # 链接格式各部分的默认值# Directorysource_dir: source # 资源文件夹，这个文件夹用来存放内容。public_dir: public # 公共文件夹，这个文件夹用于存放生成的站点文件。tag_dir: tags # 标签文件夹archive_dir: archives # 归档文件夹category_dir: categories # 分类文件夹code_dir: downloads/code # Include code 文件夹i18n_dir: :lang # 多语言文件夹skip_render: # 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。# Writingnew_post_name: :title.md # 新文章的文件名称default_layout: post # 预设布局titlecase: false # 标题首字母大写external_link: true # 在新标签中打开链接filename_case: 0 # 把文件名称转换为 (1) 小写或 (2) 大写render_drafts: false # 显示草稿post_asset_folder: false # 启动 Asset 文件夹relative_link: false # 把链接改为与根目录的相对位址future: true # 显示未来文章highlight: # 代码块社则 enable: true line_number: true auto_detect: false tab_replace: # Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: '' # 首页路径 per_page: 10 # 首页分页 order_by: -date # 首页排序 # Category &amp; Tagdefault_category: uncategorized # 默认分类category_map: # 分类别名tag_map: # 标签别名# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DD # 日期格式time_format: HH:mm:ss # 时间格式# Pagination## Set per_page to 0 to disable paginationper_page: 10 # 分页pagination_dir: page # 分页目录# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hueman # 主题 # Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: # 部署 type: git # 部署类型 repo: # 部署到哪个地址/仓库 branch: master # 分支名称 message: # 自定义提交信息 使用 init: 新建一个网站 1hexo init [folder] new: 新建一篇文章 1hexo new [layout] &lt;title&gt; generate: 生成静态网站 1hexo generate publish: 发表草稿 1hexo publish [layout] &lt;filename&gt; server: 启动服务器 1hexo server deploy: 部署网站 1hexo deplay render: 渲染文件 1hexo render &lt;file1&gt; [file2] ... migrate: 从其他博客系统迁移内容 1hexo migrate &lt;type&gt; clean: 清除缓存文件 (db.json) 和已生成的静态文件 (public) 1hexo clean list: 列出网站资料 1hexo list &lt;type&gt; version: 显示 Hexo 版本 1hexo version 插件 Git 部署插件 安装：npm install hexo-deployer-git --save 配置： 12345deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] Heroku 部署插件 安装：npm install hexo-deployer-heroku --save 配置： 1234deploy: type: heroku repo: &lt;repository url&gt; message: [message] SSH 部署插件 安装：npm install hexo-deployer-rsync --save 配置：123456789deploy: type: rsync host: &lt;host&gt; user: &lt;user&gt; root: &lt;root&gt; port: [port] delete: [true|false] # 删除远程主机上的旧文件 verbose: [true|false] # 显示调试信息 ignore_errors: [true|false] # 忽略错误 OpenShift 部署插件 安装：npm install hexo-deployer-openshift --save 配置：1234deploy: type: openshift repo: &lt;repository url&gt; message: [message] FTP 部署插件 安装：npm install hexo-deployer-ftpsync --save 配置：12345678910deploy: type: ftpsync host: &lt;host&gt; user: &lt;user&gt; pass: &lt;password&gt; remote: [remote] port: [port] ignore: [ignore] connections: [connections] verbose: [true|false] 其他 创建关于页面 使用命令 hexo new page about 创建关于文档。 像修改普通文档一样修改 ./source/about/index.md 文档。 正常发布程序。 其他不明白的地方请参考官方文档。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://shookgao.github.io/categories/学习笔记/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://shookgao.github.io/tags/学习笔记/"},{"name":"Hexo","slug":"Hexo","permalink":"https://shookgao.github.io/tags/Hexo/"}]},{"title":"FFmpeg 学习笔记","slug":"ffmpeg","date":"2018-01-01T16:00:00.000Z","updated":"2018-06-07T03:34:50.727Z","comments":true,"path":"2018/01/02/ffmpeg/","link":"","permalink":"https://shookgao.github.io/2018/01/02/ffmpeg/","excerpt":"","text":"语法 常规 1ffmpeg -i a.avi -preset ultrafast -crf 18 -c:v libx265 -c:a aac a.mp4 批处理 1for f in `ls *.avi`; do ffmpeg -i f -preset ultrafast -crf 18 -c:v libx265 -c:a aac $&#123;f%.*&#125;.mp4; done; 合并 12# 先建立filelist.txt文件，文件内每个`file \"a.avi\"`占一行，有多少填多少，然后执行ffmpeg -f concat -i filelist.txt -c copy a.mp4","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://shookgao.github.io/categories/学习笔记/"}],"tags":[{"name":"ffmpeg","slug":"ffmpeg","permalink":"https://shookgao.github.io/tags/ffmpeg/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://shookgao.github.io/tags/学习笔记/"}]},{"title":"NeDB 学习笔记","slug":"nedb","date":"2017-12-31T16:00:00.000Z","updated":"2018-05-29T16:00:00.000Z","comments":true,"path":"2018/01/01/nedb/","link":"","permalink":"https://shookgao.github.io/2018/01/01/nedb/","excerpt":"","text":"NeDB 是一个嵌入式的持久或者内存数据库，100% Javascript 编写，无二进制依赖；API 是 MongoDB 的一个子集并且它足够快。 安装npm install -S nedb API创建/加载一个数据库你可以把 NeDB 创建为一个内存数据库或者持久数据库，一个数据库相当于 MongoDB 的一个集合；new Datastore(options)是一个构造函数，options是一个对象并有以下字段：filename：可选，数据被持久存放的路径，如果留空，数据库会被创建在内存中。它不能以~结束，因为 NeDB 的临时文件要用。inMemoryOnly：可选，默认false，就如名字所标识的那个意思。timestampData：可选，默认false，所有文档插入和更新的时间戳，有两个字段：createAt和updateAt。用户指定的值会覆盖自动生产的值，通常用于测试。autoload：可选，默认false，如果适用，数据库文件会被自动加载，你不需要再使用loadDatastore命令，所有命令在加载完成前被缓存，并在加载完成后被执行。onload：可选，假如你使用自动加载，它会在loadDatastore后被调用，它得到一个error提要，当你在自动加载的时候没有指定处理器，在加载的时候发生的错误将会被抛弃。afterSerialization：你可以使用这个钩子在数据被序列化后写入磁盘文件之前转换数据，比如在写入磁盘之前加密数据，这个函数接收一个字符串作为参数，并输出转换后的字符串，必须保证不出现\\n字符，这可能会造成数据丢失。beforeDeserialization：和afterSerialization相反，并且必须两个一起使用。corruptAlertThreshold：可选，在0和1之间，默认10%，如果数据损失超过这个值，NeDB 将不能启动。compareStrings：可选，函数 compareStrings(a, b) 比较字符串 a 和 b 返回-1、0、1，如果指定，它将会覆盖默认的字符串比较函数因为默认函数不能很好的适配非美国字符，特别是重音字母，原生localCompare在绝大多数情况下是一个更好的选择。假如你使用一个持久数据库并且没有使用autoload选项，你必须手工调用loadDatastore，否则所有命令都将不能执行。12345678910111213141516171819202122232425262728// Type 1: 内存数据库(不需要加载数据库)var Datastore = require('nedb') , db = new Datastore();// Type 2: 持久数据库手工加载var Datastore = require('nedb') , db = new Datastore(&#123; filename: 'path/to/datafile' &#125;);db.loadDatabase(function (err) &#123; // Callback is optional // Now commands will be executed&#125;);// Type 3: 持久数据库自动加载var Datastore = require('nedb') , db = new Datastore(&#123; filename: 'path/to/datafile', autoload: true &#125;);// 你现在可以马上发布命令。// 当然如果你需要多个数据库你可以创建多个// 集合. 在这种情况下为所有集合使用自动加载通常是个好办法.db = &#123;&#125;;db.users = new Datastore('path/to/users.db');db.robots = new Datastore('path/to/robots.db');// 你必须加载所有数据库 (这儿我们异步处理它。)db.users.loadDatabase();db.robots.loadDatabase(); 持久化方案NeDB持久化使用附加格式，所有升级和删除的实际结果会加到数据文件的末尾。数据库自动压实。你的应用程序每次都会加载整个数据库。压实会花费一点儿时间，在这个时间内其他操作都会被停止，因此大多数项目实际上没必要使用它。插入文档原生类型是String、Number、Boolean、Date和null，你也可以使用数组和子文档（对象），假如一个字段是undefined，它将不会被保存（这和MongoDB不同，它是把undefined转换为null）。如果文档不包含_id字段，NeDB将会为你自动生成一个（一个16字符的字母数字字符串）。文档的_id字段一旦被设置就不能被修改。字段名不能以$开头并且不能包含.。1234567891011121314var doc = &#123; hello: 'world' , n: 5 , today: new Date() , nedbIsAwesome: true , notthere: null , notToBeSaved: undefined // 不保存 , fruits: [ 'apple', 'orange', 'pear' ] , infos: &#123; name: 'nedb' &#125; &#125;;db.insert(doc, function (err, newDoc) &#123; // Callback is optional // newDoc是最近插入的文档, 包含它的_id // newDoc 没有叫notToBeSaved的字段因为它的值是undefined。&#125;); 你也能够插入一个文档数组，这个操作是自动的，如果数组中的一个文档插入失败，那么所有数据都将回滚。12345678910db.insert([&#123; a: 5 &#125;, &#123; a: 42 &#125;], function (err, newDocs) &#123; // 两个文档被插入数据库中。 // newDocs是这两个文档的数组, 增加了他们的_id&#125;);// 假如在字段`a`上有唯一约束, 操作将会失败。db.insert([&#123; a: 5 &#125;, &#123; a: 42 &#125;, &#123; a: 5 &#125;], function (err) &#123; // err 是一个 'uniqueViolated' 错误 // 数据库没有被改变&#125;); 查找文档使用find查找多个文档，使用findOne查找你指定的一个文档。你也能够选择文档基于字段相等或者比较操作符($lt, $lte, $gt, $gte, $in, $nin, $ne)，你也能够使用逻辑操作符$or、$and、$not和$where，看下面的语法。你有两种办法使用正则表达式：在基础查询里面替换一个字符串，或者使用$regex操作符。你能够排序和分页使用游标 API。你能够使用标准预测限制字段出现在结果中。基础查询标准查询意思是根据你指定的字段匹配查找文档。你能用正则表达式匹配字符串。为了匹配一个数组中的指定元素，你可以使用点符号在嵌入式文档、数组、子文档数组中导航。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 我们的数据库中包含一下的集合// &#123; _id: 'id1', planet: 'Mars', system: 'solar', inhabited: false, satellites: ['Phobos', 'Deimos'] &#125;// &#123; _id: 'id2', planet: 'Earth', system: 'solar', inhabited: true, humans: &#123; genders: 2, eyes: true &#125; &#125;// &#123; _id: 'id3', planet: 'Jupiter', system: 'solar', inhabited: false &#125;// &#123; _id: 'id4', planet: 'Omicron Persei 8', system: 'futurama', inhabited: true, humans: &#123; genders: 7 &#125; &#125;// &#123; _id: 'id5', completeData: &#123; planets: [ &#123; name: 'Earth', number: 3 &#125;, &#123; name: 'Mars', number: 2 &#125;, &#123; name: 'Pluton', number: 9 &#125; ] &#125; &#125;// 在太阳系中找出所有行星db.find(&#123; system: 'solar' &#125;, function (err, docs) &#123; // docs 是一个包含 Mars, Earth, Jupiter 的数组 // 假如没有文档被发现, docs 等于 []&#125;);// 使用正则表达式找出名称中包含 ar 的行星db.find(&#123; planet: /ar/ &#125;, function (err, docs) &#123; // docs 包含 Mars 和 Earth&#125;);// 找出太阳系中有人居住的行星db.find(&#123; system: 'solar', inhabited: true &#125;, function (err, docs) &#123; // docs 是一个仅仅包含文档 Earth 的数组&#125;);// 使用点符号在子文档中匹配字段db.find(&#123; \"humans.genders\": 2 &#125;, function (err, docs) &#123; // docs 包含 Earth&#125;);// 使用点符号在子文档数组中导航db.find(&#123; \"completeData.planets.name\": \"Mars\" &#125;, function (err, docs) &#123; // docs 包含文档 5&#125;);db.find(&#123; \"completeData.planets.name\": \"Jupiter\" &#125;, function (err, docs) &#123; // docs 是空&#125;);db.find(&#123; \"completeData.planets.0.name\": \"Earth\" &#125;, function (err, docs) &#123; // docs 包含文档 5 // 假如我们把字段值换成 \"Mars\" docs 将是空的因为我们匹配了一个指定的数组元素。&#125;);// 你也可以深度比较对象. 不要使用点符号!db.find(&#123; humans: &#123; genders: 2 &#125; &#125;, function (err, docs) &#123; // docs 是空的, 因为 &#123; genders: 2 &#125; 不等于 &#123; genders: 2, eyes: true &#125;&#125;);// 在这个集合中查找所有文档db.find(&#123;&#125;, function (err, docs) &#123;&#125;);// 当你想找一个文档的时候使用 findOne，使用规则一样db.findOne(&#123; _id: 'id1' &#125;, function (err, doc) &#123; // doc 是文档 Mars // 假如没有文档被发现, doc 是 null&#125;); 操作符 ($lt, $lte, $gt, $gte, $in, $nin, $ne, $exists, $regex)这个语法是{ field: { $op: value } }，$op是任意比较操作符。 $lt,$lte：小于，小于或等于 $gt,$gte：大于，大于或等于 $in：.value的成员，必须是一个数组值 $ne,nin：不等于，不是一个成员 $exists：检查字段是否存在，值是 true 或者 false $regex：检查一个字符串是否被正则表达式匹配。和 MongoDB相反，NeDB的$regex不支持$options，因为它并没有什么卵用。123456789101112131415161718192021222324// $lt, $lte, $gt and $gte 工作在数字和字符串上db.find(&#123; \"humans.genders\": &#123; $gt: 5 &#125; &#125;, function (err, docs) &#123; // docs 包含 Omicron Persei 8, 它的 humans.genders 是7，大于5.&#125;);// 当使用在字符串上的时候，使用字典排序db.find(&#123; planet: &#123; $gt: 'Mercury' &#125;&#125;, function (err, docs) &#123; // docs contains Omicron Persei 8&#125;)// 使用 $in. $nin 的方法是一样的db.find(&#123; planet: &#123; $in: ['Earth', 'Jupiter'] &#125;&#125;, function (err, docs) &#123; // docs 包含 Earth and Jupiter&#125;);// 使用 $existsdb.find(&#123; satellites: &#123; $exists: true &#125; &#125;, function (err, docs) &#123; // docs 只包含 Mars&#125;);// 有多个操作符的时候，正则表达式要使用操作符 $regex db.find(&#123; planet: &#123; $regex: /ar/, $nin: ['Jupiter', 'Earth'] &#125; &#125;, function (err, docs) &#123; // docs 仅仅包含 Mars 因为 Earth 被 $nin 匹配了&#125;); 数组字段当一个文档的值是一个数组时，NeDB首先会看查询的值是不是数组，是的话就进行一个精确匹配，然后看是不是有数组比较函数，如果也没有，将会进行模糊匹配。 $size：匹配数组的大小 $elemMatch：至少有一个元素匹配12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 精确匹配db.find(&#123; satellites: ['Phobos', 'Deimos'] &#125;, function (err, docs) &#123; // docs 包含 Mars&#125;)db.find(&#123; satellites: ['Deimos', 'Phobos'] &#125;, function (err, docs) &#123; // docs 是空的，不同顺序也不行&#125;)// 使用指定的数组匹配函数// $elemMatch 操作符为一个文档提供匹配, 假如数组中的元素满足 `$elemMatch` 操作符的所有约束db.find(&#123; completeData: &#123; planets: &#123; $elemMatch: &#123; name: 'Earth', number: 3 &#125; &#125; &#125; &#125;, function (err, docs) &#123; // docs 包含文档 id 5 (completeData)&#125;);db.find(&#123; completeData: &#123; planets: &#123; $elemMatch: &#123; name: 'Earth', number: 5 &#125; &#125; &#125; &#125;, function (err, docs) &#123; // docs 是空的&#125;);// 你能够在 #elemMatch 查询里面使用任何的文档操作符db.find(&#123; completeData: &#123; planets: &#123; $elemMatch: &#123; name: 'Earth', number: &#123; $gt: 2 &#125; &#125; &#125; &#125; &#125;, function (err, docs) &#123; // docs 包含文档 id 5 (completeData)&#125;);// 注意：你不能在 $size 操作符里面使用比较函数, e.g. &#123; $size: &#123; $lt: 5 &#125; &#125; 将会抛出一个错误db.find(&#123; satellites: &#123; $size: 2 &#125; &#125;, function (err, docs) &#123; // docs 包含 Mars&#125;);db.find(&#123; satellites: &#123; $size: 1 &#125; &#125;, function (err, docs) &#123; // docs 是空的&#125;);// 假如文档的字段是一个数组, 匹配一个意味着匹配数组中的任意一个。db.find(&#123; satellites: 'Phobos' &#125;, function (err, docs) &#123; // docs 包含 Mars. 使用 &#123; satellites: 'Deimos' &#125; 匹配是一样的结果&#125;);// 这种查询的方式也可以使用比较函数db.find(&#123; satellites: &#123; $lt: 'Amos' &#125; &#125;, function (err, docs) &#123; // docs 是空的&#125;);// $in and $nin 操作符也可以工作db.find(&#123; satellites: &#123; $in: ['Moon', 'Deimos'] &#125; &#125;, function (err, docs) &#123; // docs 包含 Mars (Earth 文档是不完整的!)&#125;); 逻辑操作符 $or, $and, $not, $where你能够使用逻辑操作符组合查询： $or,$and：语法是{ $op: [query1, query2, ...] } $not：语法是{ $not: query } $where：语法是{ $where: function () { /* object is &quot;this&quot;, return a boolean */ } }12345678910111213141516db.find(&#123; $or: [&#123; planet: 'Earth' &#125;, &#123; planet: 'Mars' &#125;] &#125;, function (err, docs) &#123; // docs 包含 Earth 和 Mars&#125;);db.find(&#123; $not: &#123; planet: 'Earth' &#125; &#125;, function (err, docs) &#123; // docs 包含 Mars, Jupiter, Omicron Persei 8&#125;);db.find(&#123; $where: function () &#123; return Object.keys(this) &gt; 6; &#125; &#125;, function (err, docs) &#123; // docs 字段大于6个&#125;);// 你能够混合普通查询、比较函数和逻辑操作符db.find(&#123; $or: [&#123; planet: 'Earth' &#125;, &#123; planet: 'Mars' &#125;], inhabited: true &#125;, function (err, docs) &#123; // docs contains Earth&#125;); 排序和分页假如你不给 find,findOne,count 指定回调函数，一个游标对象将被返回，你能够用 sort,skip,limit 修改游标后使用exec(callback)执行它。123456789101112131415161718// 我们的数据库包含4个文档// doc1 = &#123; _id: 'id1', planet: 'Mars', system: 'solar', inhabited: false, satellites: ['Phobos', 'Deimos'] &#125;// doc2 = &#123; _id: 'id2', planet: 'Earth', system: 'solar', inhabited: true, humans: &#123; genders: 2, eyes: true &#125; &#125;// doc3 = &#123; _id: 'id3', planet: 'Jupiter', system: 'solar', inhabited: false &#125;// doc4 = &#123; _id: 'id4', planet: 'Omicron Persei 8', system: 'futurama', inhabited: true, humans: &#123; genders: 7 &#125; &#125;// 没有查询条件意味着所有结果被返回 (在游标修改前)db.find(&#123;&#125;).sort(&#123; planet: 1 &#125;).skip(1).limit(2).exec(function (err, docs) &#123; // docs 是 [doc3, doc1]&#125;);// 你可以像下面这样反向排序db.find(&#123; system: 'solar' &#125;).sort(&#123; planet: -1 &#125;).exec(function (err, docs) &#123; // docs is [doc1, doc3, doc2]&#125;);// 你可以排序一个字段，然后另一个字段，像下面那样操作:db.find(&#123;&#125;).sort(&#123; firstField: 1, secondField: -1 &#125;) ... // You understand how this works! 预测你能够给 find, findOne 第二个可选的参数，projections，这个语法和MongoDB一样：{ a: 1, b: 1 }表明要返回这两个字段，{ a: 0, b: 0 }表明不要返回这两个字段，这两个方式不能同时使用，除了_id这个字段总是会返回，你可以省略它。12345678910111213141516171819202122232425262728293031// 和上面的数据库一样// 仅仅要给出的字段db.find(&#123; planet: 'Mars' &#125;, &#123; planet: 1, system: 1 &#125;, function (err, docs) &#123; // docs is [&#123; planet: 'Mars', system: 'solar', _id: 'id1' &#125;]&#125;);// 保持给出的字段并省略_iddb.find(&#123; planet: 'Mars' &#125;, &#123; planet: 1, system: 1, _id: 0 &#125;, function (err, docs) &#123; // docs is [&#123; planet: 'Mars', system: 'solar' &#125;]&#125;);// 省略给出的字段db.find(&#123; planet: 'Mars' &#125;, &#123; planet: 0, system: 0, _id: 0 &#125;, function (err, docs) &#123; // docs is [&#123; inhabited: false, satellites: ['Phobos', 'Deimos'] &#125;]&#125;);// 失败: 在同一次使用了两个方式db.find(&#123; planet: 'Mars' &#125;, &#123; planet: 0, system: 1 &#125;, function (err, docs) &#123; // err is the error message, docs is undefined&#125;);// 你也可以在游标中使用这个方式，但是和 MongoDB 不兼容db.find(&#123; planet: 'Mars' &#125;).projection(&#123; planet: 1, system: 1 &#125;).exec(function (err, docs) &#123; // docs is [&#123; planet: 'Mars', system: 'solar', _id: 'id1' &#125;]&#125;);// 在嵌入文档中使用db.findOne(&#123; planet: 'Earth' &#125;).projection(&#123; planet: 1, 'humans.genders': 1 &#125;).exec(function (err, doc) &#123; // doc is &#123; planet: 'Earth', _id: 'id2', humans: &#123; genders: 2 &#125; &#125;&#125;); 文档计数你能够使用 count 来计数，它的语法和 find 一样，例如：123456789// 计数太阳系中所有行星db.count(&#123; system: 'solar' &#125;, function (err, count) &#123; // count 等于 3&#125;);// Count 数据库中所有文档db.count(&#123;&#125;, function (err, count) &#123; // count 等于 4&#125;); 更新文档db.update(query, update, options, callback)将会升级所有匹配query的文档的update: query的方法和find方法一样。 update指定要更新什么内容，这是一个新文档或者一组字段修改。 新文档会替换旧文档 如果字段不存在会新增，可用字段修改使用$set，$unset会删除一个字段，$inc增加一个字段的值，还有$min和$max不知道有什么用；为了工作在数组上，你还可用$push, $pop, $addToSet, $pull, $each and $slice。 options是有两个可能参数的对象 multi：默认是false，同时修改多个文档 upsert：默认是false returnUpdatedDocs：默认是false，和MongoDB不兼容 callback：可选，(err, numAffected, affectedDocuments, upsert) 在upsert时，affectedDocuments包含插入的文档，upsert标志是true 在标准更新中并且returnUpdatedDocs设置为false时，affectedDocuments不会被设置。 在标准更新中并且returnUpdatedDocs设置为true并且multi为false时，affectedDocuments是更新文档 在标准更新中并且returnUpdatedDocs设置为true并且multi为true时，affectedDocuments是更新文档数组。注意：你不能改变一个文档的_id123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107// 我们的数据库是这样// &#123; _id: 'id1', planet: 'Mars', system: 'solar', inhabited: false &#125;// &#123; _id: 'id2', planet: 'Earth', system: 'solar', inhabited: true &#125;// &#123; _id: 'id3', planet: 'Jupiter', system: 'solar', inhabited: false &#125;// &#123; _id: 'id4', planet: 'Omicron Persia 8', system: 'futurama', inhabited: true &#125;// 替换一个文档db.update(&#123; planet: 'Jupiter' &#125;, &#123; planet: 'Pluton'&#125;, &#123;&#125;, function (err, numReplaced) &#123; // numReplaced = 1 // 文档 #3 已经被替换成 &#123; _id: 'id3', planet: 'Pluton' &#125; // 注意这个`_id`是保持没变的 // (这个`system`和`inhabited`字段不在这儿了)&#125;);// 设置一个已存在字段的值db.update(&#123; system: 'solar' &#125;, &#123; $set: &#123; system: 'solar system' &#125; &#125;, &#123; multi: true &#125;, function (err, numReplaced) &#123; // numReplaced = 3 // 字段 'system' 在 Mars, Earth, Jupiter 里面现在是 'solar system'&#125;);// 使用点符号在一个子文档里面设置一个不存在的字段的值db.update(&#123; planet: 'Mars' &#125;, &#123; $set: &#123; \"data.satellites\": 2, \"data.red\": true &#125; &#125;, &#123;&#125;, function () &#123; // Mars 文档现在是 &#123; _id: 'id1', system: 'solar', inhabited: false // , data: &#123; satellites: 2, red: true &#125; // &#125; // 子文档中设置字段，你必须使用点符号 // 使用对象符号仅仅能够替换顶层字段 db.update(&#123; planet: 'Mars' &#125;, &#123; $set: &#123; data: &#123; satellites: 3 &#125; &#125; &#125;, &#123;&#125;, function () &#123; // Mars 现在是 &#123; _id: 'id1', system: 'solar', inhabited: false // , data: &#123; satellites: 3 &#125; // &#125; // 你失去了 \"data.red\" 字段，这可能不是你想要的 &#125;);&#125;);// 删除一个字段db.update(&#123; planet: 'Mars' &#125;, &#123; $unset: &#123; planet: true &#125; &#125;, &#123;&#125;, function () &#123; // 现在 Mars 文档不包含 planet 字段 // 你可以使用点符号删除一个嵌入的字段&#125;);// 更新插入文档db.update(&#123; planet: 'Pluton' &#125;, &#123; planet: 'Pluton', inhabited: false &#125;, &#123; upsert: true &#125;, function (err, numReplaced, upsert) &#123; // numReplaced = 1, upsert = &#123; _id: 'id5', planet: 'Pluton', inhabited: false &#125; // 一个新的文档 &#123; _id: 'id5', planet: 'Pluton', inhabited: false &#125; 已经被加到集合中。&#125;);// 假如你插入一个修改, 这个插入的文档是查询修改// 这比听起来更简单 :)db.update(&#123; planet: 'Pluton' &#125;, &#123; $inc: &#123; distance: 38 &#125; &#125;, &#123; upsert: true &#125;, function () &#123; // 一个新文档 &#123; _id: 'id5', planet: 'Pluton', distance: 38 &#125; 被加到这个集合 &#125;);// 假如我们在集合中插入一个 &#123; _id: 'id6', fruits: ['apple', 'orange', 'pear'] &#125; 文档,// 让我们看一下我们怎么修改数组字段// $push 在数组的结尾插入新的值db.update(&#123; _id: 'id6' &#125;, &#123; $push: &#123; fruits: 'banana' &#125; &#125;, &#123;&#125;, function () &#123; // 现在这个fruits数组是 ['apple', 'orange', 'pear', 'banana']&#125;);// $pop 移除一个元素，从结尾移除用1，从开始移除使用-1db.update(&#123; _id: 'id6' &#125;, &#123; $pop: &#123; fruits: 1 &#125; &#125;, &#123;&#125;, function () &#123; // 现在 fruits 数组是 ['apple', 'orange'] // W使用 &#123; $pop: &#123; fruits: -1 &#125; &#125;, 结果会变成 ['orange', 'pear']&#125;);// $addToSet adds an element to an array only if it isn't already in it// Equality is deep-checked (i.e. $addToSet will not insert an object in an array already containing the same object)// Note that it doesn't check whether the array contained duplicates before or notdb.update(&#123; _id: 'id6' &#125;, &#123; $addToSet: &#123; fruits: 'apple' &#125; &#125;, &#123;&#125;, function () &#123; // The fruits array didn't change // If we had used a fruit not in the array, e.g. 'banana', it would have been added to the array&#125;);// $pull removes all values matching a value or even any NeDB query from the arraydb.update(&#123; _id: 'id6' &#125;, &#123; $pull: &#123; fruits: 'apple' &#125; &#125;, &#123;&#125;, function () &#123; // Now the fruits array is ['orange', 'pear']&#125;);db.update(&#123; _id: 'id6' &#125;, &#123; $pull: &#123; fruits: $in: ['apple', 'pear'] &#125; &#125;, &#123;&#125;, function () &#123; // Now the fruits array is ['orange']&#125;);// $each can be used to $push or $addToSet multiple values at once// This example works the same way with $addToSetdb.update(&#123; _id: 'id6' &#125;, &#123; $push: &#123; fruits: &#123; $each: ['banana', 'orange'] &#125; &#125; &#125;, &#123;&#125;, function () &#123; // Now the fruits array is ['apple', 'orange', 'pear', 'banana', 'orange']&#125;);// $slice can be used in cunjunction with $push and $each to limit the size of the resulting array.// A value of 0 will update the array to an empty array. A positive value n will keep only the n first elements// A negative value -n will keep only the last n elements.// If $slice is specified but not $each, $each is set to []db.update(&#123; _id: 'id6' &#125;, &#123; $push: &#123; fruits: &#123; $each: ['banana'], $slice: 2 &#125; &#125; &#125;, &#123;&#125;, function () &#123; // Now the fruits array is ['apple', 'orange']&#125;);// $min/$max to update only if provided value is less/greater than current value// Let's say the database contains this document// doc = &#123; _id: 'id', name: 'Name', value: 5 &#125;db.update(&#123; _id: 'id1' &#125;, &#123; $min: &#123; value: 2 &#125; &#125;, &#123;&#125;, function () &#123; // The document will be updated to &#123; _id: 'id', name: 'Name', value: 2 &#125;&#125;);db.update(&#123; _id: 'id1' &#125;, &#123; $min: &#123; value: 8 &#125; &#125;, &#123;&#125;, function () &#123; // The document will not be modified&#125;);","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://shookgao.github.io/categories/学习笔记/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://shookgao.github.io/tags/学习笔记/"},{"name":"NeDB","slug":"NeDB","permalink":"https://shookgao.github.io/tags/NeDB/"},{"name":"数据库","slug":"数据库","permalink":"https://shookgao.github.io/tags/数据库/"}]}]}